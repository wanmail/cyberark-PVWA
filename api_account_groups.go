/*
Privileged Access Security REST API

Display the PVWA REST APIs below for a description of how to use them and try them out. Access information about additional REST APIs through the online documentation.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AccountGroupsApiService AccountGroupsApi service
type AccountGroupsApiService service

type ApiAccountGroupsAddAccountGroupRequest struct {
	ctx context.Context
	ApiService *AccountGroupsApiService
	addAccountGroupData *AddAccountGroupData
}

// The account group data
func (r ApiAccountGroupsAddAccountGroupRequest) AddAccountGroupData(addAccountGroupData AddAccountGroupData) ApiAccountGroupsAddAccountGroupRequest {
	r.addAccountGroupData = &addAccountGroupData
	return r
}

func (r ApiAccountGroupsAddAccountGroupRequest) Execute() (*AccountGroup, *http.Response, error) {
	return r.ApiService.AccountGroupsAddAccountGroupExecute(r)
}

/*
AccountGroupsAddAccountGroup Method for AccountGroupsAddAccountGroup

This method enables application managers to define a new account group automatically, and manage accounts as part of a group.

To create an account group, users require the following permissions in the Safe where the group is created:
Add accounts, Update account content, Update account properties, Create folders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountGroupsAddAccountGroupRequest
*/
func (a *AccountGroupsApiService) AccountGroupsAddAccountGroup(ctx context.Context) ApiAccountGroupsAddAccountGroupRequest {
	return ApiAccountGroupsAddAccountGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountGroup
func (a *AccountGroupsApiService) AccountGroupsAddAccountGroupExecute(r ApiAccountGroupsAddAccountGroupRequest) (*AccountGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountGroupsApiService.AccountGroupsAddAccountGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/AccountGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addAccountGroupData == nil {
		return localVarReturnValue, nil, reportError("addAccountGroupData is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addAccountGroupData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountGroupsAddAccountToGroupRequest struct {
	ctx context.Context
	ApiService *AccountGroupsApiService
	groupId string
	addMemberData *AddMemberToAccountGroup
}

// The member to add
func (r ApiAccountGroupsAddAccountToGroupRequest) AddMemberData(addMemberData AddMemberToAccountGroup) ApiAccountGroupsAddAccountToGroupRequest {
	r.addMemberData = &addMemberData
	return r
}

func (r ApiAccountGroupsAddAccountToGroupRequest) Execute() (*AddMemberToAccountGroup, *http.Response, error) {
	return r.ApiService.AccountGroupsAddAccountToGroupExecute(r)
}

/*
AccountGroupsAddAccountToGroup Method for AccountGroupsAddAccountToGroup

This method adds an account as a member to an existing account group. 

The account can contain either a password or an SSH key. All members of an account group must be stored in the same Safe as the group itself.

To add an account as a member to an account group, users require the following permissions in the Safe where the group is created:
Add accounts, Update account content, Update account properties.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The unique ID of account group.
 @return ApiAccountGroupsAddAccountToGroupRequest
*/
func (a *AccountGroupsApiService) AccountGroupsAddAccountToGroup(ctx context.Context, groupId string) ApiAccountGroupsAddAccountToGroupRequest {
	return ApiAccountGroupsAddAccountToGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AddMemberToAccountGroup
func (a *AccountGroupsApiService) AccountGroupsAddAccountToGroupExecute(r ApiAccountGroupsAddAccountToGroupRequest) (*AddMemberToAccountGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddMemberToAccountGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountGroupsApiService.AccountGroupsAddAccountToGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/AccountGroups/{groupId}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addMemberData == nil {
		return localVarReturnValue, nil, reportError("addMemberData is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addMemberData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountGroupsDeleteAccountFromGroupRequest struct {
	ctx context.Context
	ApiService *AccountGroupsApiService
	groupId string
	accountId string
}

func (r ApiAccountGroupsDeleteAccountFromGroupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AccountGroupsDeleteAccountFromGroupExecute(r)
}

/*
AccountGroupsDeleteAccountFromGroup Method for AccountGroupsDeleteAccountFromGroup

This method removes an account member from an account group. This account can be either a password account or an SSH Key account.

The user performing this task must have the following permissions in the Safe:
Add accounts, Update account content, Update account properties, Create folders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The unique ID of the group.
 @param accountId The unique ID of the account.
 @return ApiAccountGroupsDeleteAccountFromGroupRequest
*/
func (a *AccountGroupsApiService) AccountGroupsDeleteAccountFromGroup(ctx context.Context, groupId string, accountId string) ApiAccountGroupsDeleteAccountFromGroupRequest {
	return ApiAccountGroupsDeleteAccountFromGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AccountGroupsApiService) AccountGroupsDeleteAccountFromGroupExecute(r ApiAccountGroupsDeleteAccountFromGroupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountGroupsApiService.AccountGroupsDeleteAccountFromGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/AccountGroups/{groupId}/members/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountGroupsGetGroupAccountsRequest struct {
	ctx context.Context
	ApiService *AccountGroupsApiService
	groupId string
}

func (r ApiAccountGroupsGetGroupAccountsRequest) Execute() (*AccountGroupMember, *http.Response, error) {
	return r.ApiService.AccountGroupsGetGroupAccountsExecute(r)
}

/*
AccountGroupsGetGroupAccounts Method for AccountGroupsGetGroupAccounts

This method returns all the members of an existing account group. These accounts can be either password accounts or SSH Key accounts.

The user performing this task must have the following permissions in the Safe:
List Accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The unique ID of the group.
 @return ApiAccountGroupsGetGroupAccountsRequest
*/
func (a *AccountGroupsApiService) AccountGroupsGetGroupAccounts(ctx context.Context, groupId string) ApiAccountGroupsGetGroupAccountsRequest {
	return ApiAccountGroupsGetGroupAccountsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return AccountGroupMember
func (a *AccountGroupsApiService) AccountGroupsGetGroupAccountsExecute(r ApiAccountGroupsGetGroupAccountsRequest) (*AccountGroupMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountGroupMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountGroupsApiService.AccountGroupsGetGroupAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/AccountGroups/{groupId}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAccountGroupsGetGroupsRequest struct {
	ctx context.Context
	ApiService *AccountGroupsApiService
	safe *string
}

// The name of the Safe where the account groups are.
func (r ApiAccountGroupsGetGroupsRequest) Safe(safe string) ApiAccountGroupsGetGroupsRequest {
	r.safe = &safe
	return r
}

func (r ApiAccountGroupsGetGroupsRequest) Execute() (*AccountGroup, *http.Response, error) {
	return r.ApiService.AccountGroupsGetGroupsExecute(r)
}

/*
AccountGroupsGetGroups Method for AccountGroupsGetGroups

This method returns all the account groups in a specific Safe. 

The user performing this task must have the following permissions in the Safe:
List Accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAccountGroupsGetGroupsRequest
*/
func (a *AccountGroupsApiService) AccountGroupsGetGroups(ctx context.Context) ApiAccountGroupsGetGroupsRequest {
	return ApiAccountGroupsGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountGroup
func (a *AccountGroupsApiService) AccountGroupsGetGroupsExecute(r ApiAccountGroupsGetGroupsRequest) (*AccountGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountGroupsApiService.AccountGroupsGetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/AccountGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.safe != nil {
		localVarQueryParams.Add("safe", parameterToString(*r.safe, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
