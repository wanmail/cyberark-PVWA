/*
Privileged Access Security REST API

Display the PVWA REST APIs below for a description of how to use them and try them out. Access information about additional REST APIs through the online documentation.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// AuthApiService AuthApi service
type AuthApiService service

type ApiAuthLogoffRequest struct {
	ctx context.Context
	ApiService *AuthApiService
}

func (r ApiAuthLogoffRequest) Execute() (*LogoffData, *http.Response, error) {
	return r.ApiService.AuthLogoffExecute(r)
}

/*
AuthLogoff Method for AuthLogoff

This method logs off the user and removes the Vault session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthLogoffRequest
*/
func (a *AuthApiService) AuthLogoff(ctx context.Context) ApiAuthLogoffRequest {
	return ApiAuthLogoffRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LogoffData
func (a *AuthApiService) AuthLogoffExecute(r ApiAuthLogoffRequest) (*LogoffData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LogoffData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.AuthLogoff")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Auth/Logoff"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthLogonRequest struct {
	ctx context.Context
	ApiService *AuthApiService
	type_ string
	data *LogonData
}

// The login information.
func (r ApiAuthLogonRequest) Data(data LogonData) ApiAuthLogonRequest {
	r.data = &data
	return r
}

func (r ApiAuthLogonRequest) Execute() (*string, *http.Response, error) {
	return r.ApiService.AuthLogonExecute(r)
}

/*
AuthLogon Method for AuthLogon

This method authenticates a user to the Vault and returns a token that can be used in subsequent web services calls.

In addition, this method allows you to set a new password.

After the configured timeout expires, users have to log on again using their username and password.

Users can authenticate using CyberArk, Windows, LDAP, RADIUS or SAML authentication.

For Windows authentication type:

Windows authentication require to negotiate NTLM request and response access in order to logon using  windows credentials.

For SAML authentication type:

For SAML authentication you need to send the header "Content-Type" with value set to "application/x-www-form-urlencoded", alongside the following keys:  

•	“SAMLResponse” and its value (Required)

•	“apiUse” set to “true” (Required)

•	“concurrentSession” set to "true" or "false" (Optional)

•	“secureMode” set to "true" or "false" (Optional)

The keys should be encoded in key-value tuples separated by '&amp;'.  <br />
Each key and value should be separated by  '=’.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ The authentication type. (for example: cyberark)
 @return ApiAuthLogonRequest
*/
func (a *AuthApiService) AuthLogon(ctx context.Context, type_ string) ApiAuthLogonRequest {
	return ApiAuthLogonRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
func (a *AuthApiService) AuthLogonExecute(r ApiAuthLogonRequest) (*string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.AuthLogon")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Auth/{type}/Logon"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterToString(r.type_, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	if len(localVarBody) < 2 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: "invalid token",
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	// 去除引号
	if localVarBody[0] == 34 {
		localVarReturnValue = PtrString(string(localVarBody[1:len(localVarBody)-1]))
	}


	return localVarReturnValue, localVarHTTPResponse, nil
}
