/*
Privileged Access Security REST API

Display the PVWA REST APIs below for a description of how to use them and try them out. Access information about additional REST APIs through the online documentation.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// LDAPDirectoriesApiService LDAPDirectoriesApi service
type LDAPDirectoriesApiService service

type ApiLDAPDirectoriesAddDirectoryRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directory *LDAPDirectory
}

func (r ApiLDAPDirectoriesAddDirectoryRequest) Directory(directory LDAPDirectory) ApiLDAPDirectoriesAddDirectoryRequest {
	r.directory = &directory
	return r
}

func (r ApiLDAPDirectoriesAddDirectoryRequest) Execute() (*LDAPDirectory, *http.Response, error) {
	return r.ApiService.LDAPDirectoriesAddDirectoryExecute(r)
}

/*
LDAPDirectoriesAddDirectory Method for LDAPDirectoriesAddDirectory

This method creates a directory in the Vault.

Any user who is a member of the Vault Admins group can run this WS.

Note: The BindUsername and BindPassword parameters are only optional if you have the bind user account already onboarded to the Vault Internal  safe (the account name must be DomainName.pass)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLDAPDirectoriesAddDirectoryRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesAddDirectory(ctx context.Context) ApiLDAPDirectoriesAddDirectoryRequest {
	return ApiLDAPDirectoriesAddDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LDAPDirectory
func (a *LDAPDirectoriesApiService) LDAPDirectoriesAddDirectoryExecute(r ApiLDAPDirectoriesAddDirectoryRequest) (*LDAPDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LDAPDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesAddDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.directory == nil {
		return localVarReturnValue, nil, reportError("directory is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.directory
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesAddDirectoryMappingRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
	mappingData *LDAPMappingData
}

func (r ApiLDAPDirectoriesAddDirectoryMappingRequest) MappingData(mappingData LDAPMappingData) ApiLDAPDirectoriesAddDirectoryMappingRequest {
	r.mappingData = &mappingData
	return r
}

func (r ApiLDAPDirectoriesAddDirectoryMappingRequest) Execute() (*LDAPMappingData, *http.Response, error) {
	return r.ApiService.LDAPDirectoriesAddDirectoryMappingExecute(r)
}

/*
LDAPDirectoriesAddDirectoryMapping Method for LDAPDirectoriesAddDirectoryMapping

This method creates a directory mapping in the Vault.

Every user that is a member of the Vault Admins group and has the following Vault authorizations can run this web service:

"Audit users",
"Add/Update users",
"Manage Directory mappings"

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName
 @return ApiLDAPDirectoriesAddDirectoryMappingRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesAddDirectoryMapping(ctx context.Context, directoryName string) ApiLDAPDirectoriesAddDirectoryMappingRequest {
	return ApiLDAPDirectoriesAddDirectoryMappingRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
	}
}

// Execute executes the request
//  @return LDAPMappingData
func (a *LDAPDirectoriesApiService) LDAPDirectoriesAddDirectoryMappingExecute(r ApiLDAPDirectoriesAddDirectoryMappingRequest) (*LDAPMappingData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LDAPMappingData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesAddDirectoryMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}/Mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mappingData == nil {
		return localVarReturnValue, nil, reportError("mappingData is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mappingData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesDeleteDirectoryRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
}

func (r ApiLDAPDirectoriesDeleteDirectoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.LDAPDirectoriesDeleteDirectoryExecute(r)
}

/*
LDAPDirectoriesDeleteDirectory Method for LDAPDirectoriesDeleteDirectory

This method deletes a specific directory along with its mappings.

Every user that is a member of the Vault Admins group and has the following Vault authorizations can run this web service:

"Audit users",
"Add/Update users",
"Manage Directory mappings",
"Add Safes",
"Reset Users' Passwords",
"Activate Users",
"Add Network Areas",
"Manage Server File Categories"

Note: Once a mapping is deleted, all LDAP users created in the Vault and mapped to this mapping will be automatically deleted in the Vault during the next periodic LDAP sync.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName
 @return ApiLDAPDirectoriesDeleteDirectoryRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesDeleteDirectory(ctx context.Context, directoryName string) ApiLDAPDirectoriesDeleteDirectoryRequest {
	return ApiLDAPDirectoriesDeleteDirectoryRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
	}
}

// Execute executes the request
func (a *LDAPDirectoriesApiService) LDAPDirectoriesDeleteDirectoryExecute(r ApiLDAPDirectoriesDeleteDirectoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesDeleteDirectory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesDeleteDirectoryMappingRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
	mappingID int64
}

func (r ApiLDAPDirectoriesDeleteDirectoryMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.LDAPDirectoriesDeleteDirectoryMappingExecute(r)
}

/*
LDAPDirectoriesDeleteDirectoryMapping Method for LDAPDirectoriesDeleteDirectoryMapping

This method deletes a specific directory mapping.

To run this method you must:

1. Be a member of Vault Admin group and have the Manage Directory Mapping authorization.   
2. Have at least all the authorizations that the mapping has.

 
  Note: Once a mapping is deleted, all LDAP users created in the Vault and mapped to this mapping will be automatically deleted from the vault during the next periodic LDAP sync.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName The Directory name
 @param mappingID The Mapping id to delete
 @return ApiLDAPDirectoriesDeleteDirectoryMappingRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesDeleteDirectoryMapping(ctx context.Context, directoryName string, mappingID int64) ApiLDAPDirectoriesDeleteDirectoryMappingRequest {
	return ApiLDAPDirectoriesDeleteDirectoryMappingRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
		mappingID: mappingID,
	}
}

// Execute executes the request
func (a *LDAPDirectoriesApiService) LDAPDirectoriesDeleteDirectoryMappingExecute(r ApiLDAPDirectoriesDeleteDirectoryMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesDeleteDirectoryMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}/Mappings/{mappingID}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mappingID"+"}", url.PathEscape(parameterToString(r.mappingID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesGetDirectoriesRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
}

func (r ApiLDAPDirectoriesGetDirectoriesRequest) Execute() ([]LDAPDirectoryBase, *http.Response, error) {
	return r.ApiService.LDAPDirectoriesGetDirectoriesExecute(r)
}

/*
LDAPDirectoriesGetDirectories Method for LDAPDirectoriesGetDirectories

This method returns a list of existing directories in the Vault.

Each directory will be returned with its own data.

To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLDAPDirectoriesGetDirectoriesRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectories(ctx context.Context) ApiLDAPDirectoriesGetDirectoriesRequest {
	return ApiLDAPDirectoriesGetDirectoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LDAPDirectoryBase
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectoriesExecute(r ApiLDAPDirectoriesGetDirectoriesRequest) ([]LDAPDirectoryBase, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LDAPDirectoryBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesGetDirectories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesGetDirectoryRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
}

func (r ApiLDAPDirectoriesGetDirectoryRequest) Execute() (*LDAPDirectory, *http.Response, error) {
	return r.ApiService.LDAPDirectoriesGetDirectoryExecute(r)
}

/*
LDAPDirectoriesGetDirectory Method for LDAPDirectoriesGetDirectory

This method returns all the details of a specific directory that is defined in the Vault.

To run this web service, the user must be a member of the Vault Admins group and have Audit Users permissions.

Note: be sure to add '/' at the end of the URL of this web service.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName The address/DNS name of the domain.
 @return ApiLDAPDirectoriesGetDirectoryRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectory(ctx context.Context, directoryName string) ApiLDAPDirectoriesGetDirectoryRequest {
	return ApiLDAPDirectoriesGetDirectoryRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
	}
}

// Execute executes the request
//  @return LDAPDirectory
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectoryExecute(r ApiLDAPDirectoriesGetDirectoryRequest) (*LDAPDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LDAPDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesGetDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesGetDirectoryMappingRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
	mappingID int64
}

func (r ApiLDAPDirectoriesGetDirectoryMappingRequest) Execute() (*LDAPMappingData, *http.Response, error) {
	return r.ApiService.LDAPDirectoriesGetDirectoryMappingExecute(r)
}

/*
LDAPDirectoriesGetDirectoryMapping Method for LDAPDirectoriesGetDirectoryMapping

This method returns all the details of specific directory mapping that is defined in the Vault.
To run this web service, the user must be a member of the Vault Admins group and have permissions to "Manage Directory Mapping" (Vault Authorization).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName The address/DNS name of the domain.
 @param mappingID Unique ID of the directory mapping.
 @return ApiLDAPDirectoriesGetDirectoryMappingRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectoryMapping(ctx context.Context, directoryName string, mappingID int64) ApiLDAPDirectoriesGetDirectoryMappingRequest {
	return ApiLDAPDirectoriesGetDirectoryMappingRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
		mappingID: mappingID,
	}
}

// Execute executes the request
//  @return LDAPMappingData
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectoryMappingExecute(r ApiLDAPDirectoriesGetDirectoryMappingRequest) (*LDAPMappingData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LDAPMappingData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesGetDirectoryMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}/Mappings/{mappingID}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mappingID"+"}", url.PathEscape(parameterToString(r.mappingID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesGetDirectoryMappingsRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
}

func (r ApiLDAPDirectoriesGetDirectoryMappingsRequest) Execute() ([]LDAPMappingData, *http.Response, error) {
	return r.ApiService.LDAPDirectoriesGetDirectoryMappingsExecute(r)
}

/*
LDAPDirectoriesGetDirectoryMappings Method for LDAPDirectoriesGetDirectoryMappings

This method returns a list of existing directory mappings in the Vault.

To run this web service, the user must be a member of the Vault Admins group and have
permissions to "Manage Directory Mapping" (Vault Authorization).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName Directory name
 @return ApiLDAPDirectoriesGetDirectoryMappingsRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectoryMappings(ctx context.Context, directoryName string) ApiLDAPDirectoriesGetDirectoryMappingsRequest {
	return ApiLDAPDirectoriesGetDirectoryMappingsRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
	}
}

// Execute executes the request
//  @return []LDAPMappingData
func (a *LDAPDirectoriesApiService) LDAPDirectoriesGetDirectoryMappingsExecute(r ApiLDAPDirectoriesGetDirectoryMappingsRequest) ([]LDAPMappingData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LDAPMappingData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesGetDirectoryMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}/Mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
	mappingsOrder *LDAPMappingsOrder
}

func (r ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest) MappingsOrder(mappingsOrder LDAPMappingsOrder) ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest {
	r.mappingsOrder = &mappingsOrder
	return r
}

func (r ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest) Execute() (*http.Response, error) {
	return r.ApiService.LDAPDirectoriesSetDirectoryMappingsOrderExecute(r)
}

/*
LDAPDirectoriesSetDirectoryMappingsOrder Method for LDAPDirectoriesSetDirectoryMappingsOrder

This method will modify the order of all mappings that belong to a certain directory.
 Every user that is a member of the Vault Admins group and has the following Vault authorizations can run this web service:

"Audit users",
"Add/Update users",
"Manage Directory mappings"

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName Directory name
 @return ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesSetDirectoryMappingsOrder(ctx context.Context, directoryName string) ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest {
	return ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
	}
}

// Execute executes the request
func (a *LDAPDirectoriesApiService) LDAPDirectoriesSetDirectoryMappingsOrderExecute(r ApiLDAPDirectoriesSetDirectoryMappingsOrderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesSetDirectoryMappingsOrder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}/Mappings/Reorder"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mappingsOrder == nil {
		return nil, reportError("mappingsOrder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mappingsOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLDAPDirectoriesUpdateDirectoryMappingRequest struct {
	ctx context.Context
	ApiService *LDAPDirectoriesApiService
	directoryName string
	mappingID int64
	mappingToEdit *LDAPMappingData
}

// Updated Mapping data
func (r ApiLDAPDirectoriesUpdateDirectoryMappingRequest) MappingToEdit(mappingToEdit LDAPMappingData) ApiLDAPDirectoriesUpdateDirectoryMappingRequest {
	r.mappingToEdit = &mappingToEdit
	return r
}

func (r ApiLDAPDirectoriesUpdateDirectoryMappingRequest) Execute() (*LDAPMappingData, *http.Response, error) {
	return r.ApiService.LDAPDirectoriesUpdateDirectoryMappingExecute(r)
}

/*
LDAPDirectoriesUpdateDirectoryMapping Method for LDAPDirectoriesUpdateDirectoryMapping

This method edits an existing directory mapping.
Every user that is a member of the Vault Admins group and has the following Vault authorizations can run this web service:

"Audit users"
"Add/Update users"
"Manage Directory mappings"

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryName Directory name
 @param mappingID Mapping ID
 @return ApiLDAPDirectoriesUpdateDirectoryMappingRequest
*/
func (a *LDAPDirectoriesApiService) LDAPDirectoriesUpdateDirectoryMapping(ctx context.Context, directoryName string, mappingID int64) ApiLDAPDirectoriesUpdateDirectoryMappingRequest {
	return ApiLDAPDirectoriesUpdateDirectoryMappingRequest{
		ApiService: a,
		ctx: ctx,
		directoryName: directoryName,
		mappingID: mappingID,
	}
}

// Execute executes the request
//  @return LDAPMappingData
func (a *LDAPDirectoriesApiService) LDAPDirectoriesUpdateDirectoryMappingExecute(r ApiLDAPDirectoriesUpdateDirectoryMappingRequest) (*LDAPMappingData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LDAPMappingData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LDAPDirectoriesApiService.LDAPDirectoriesUpdateDirectoryMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Configuration/LDAP/Directories/{directoryName}/Mappings/{mappingID}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryName"+"}", url.PathEscape(parameterToString(r.directoryName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mappingID"+"}", url.PathEscape(parameterToString(r.mappingID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mappingToEdit == nil {
		return localVarReturnValue, nil, reportError("mappingToEdit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mappingToEdit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
