/*
Privileged Access Security REST API

Display the PVWA REST APIs below for a description of how to use them and try them out. Access information about additional REST APIs through the online documentation.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// LiveSessionsApiService LiveSessionsApi service
type LiveSessionsApiService service

type ApiLiveSessionsGetLiveSessionRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	liveSessionId string
	returnURL *string
}

func (r ApiLiveSessionsGetLiveSessionRequest) ReturnURL(returnURL string) ApiLiveSessionsGetLiveSessionRequest {
	r.returnURL = &returnURL
	return r
}

func (r ApiLiveSessionsGetLiveSessionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LiveSessionsGetLiveSessionExecute(r)
}

/*
LiveSessionsGetLiveSession Method for LiveSessionsGetLiveSession

This method returns details of an active session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveSessionId The unique ID of the PSM Active Session.
 @return ApiLiveSessionsGetLiveSessionRequest
*/
func (a *LiveSessionsApiService) LiveSessionsGetLiveSession(ctx context.Context, liveSessionId string) ApiLiveSessionsGetLiveSessionRequest {
	return ApiLiveSessionsGetLiveSessionRequest{
		ApiService: a,
		ctx: ctx,
		liveSessionId: liveSessionId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LiveSessionsApiService) LiveSessionsGetLiveSessionExecute(r ApiLiveSessionsGetLiveSessionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsGetLiveSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions/{liveSessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"liveSessionId"+"}", url.PathEscape(parameterToString(r.liveSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnURL != nil {
		localVarQueryParams.Add("returnURL", parameterToString(*r.returnURL, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveSessionsGetLiveSessionActivitiesRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	liveSessionId string
}

func (r ApiLiveSessionsGetLiveSessionActivitiesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LiveSessionsGetLiveSessionActivitiesExecute(r)
}

/*
LiveSessionsGetLiveSessionActivities Method for LiveSessionsGetLiveSessionActivities

This method returns activities of an active session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveSessionId The unique ID of the PSM Active Session.
 @return ApiLiveSessionsGetLiveSessionActivitiesRequest
*/
func (a *LiveSessionsApiService) LiveSessionsGetLiveSessionActivities(ctx context.Context, liveSessionId string) ApiLiveSessionsGetLiveSessionActivitiesRequest {
	return ApiLiveSessionsGetLiveSessionActivitiesRequest{
		ApiService: a,
		ctx: ctx,
		liveSessionId: liveSessionId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LiveSessionsApiService) LiveSessionsGetLiveSessionActivitiesExecute(r ApiLiveSessionsGetLiveSessionActivitiesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsGetLiveSessionActivities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions/{liveSessionId}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"liveSessionId"+"}", url.PathEscape(parameterToString(r.liveSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveSessionsGetLiveSessionPropertiesRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	liveSessionId string
}

func (r ApiLiveSessionsGetLiveSessionPropertiesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.LiveSessionsGetLiveSessionPropertiesExecute(r)
}

/*
LiveSessionsGetLiveSessionProperties Method for LiveSessionsGetLiveSessionProperties

This method returns properties of an active session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveSessionId The unique ID of the PSM Active Session.
 @return ApiLiveSessionsGetLiveSessionPropertiesRequest
*/
func (a *LiveSessionsApiService) LiveSessionsGetLiveSessionProperties(ctx context.Context, liveSessionId string) ApiLiveSessionsGetLiveSessionPropertiesRequest {
	return ApiLiveSessionsGetLiveSessionPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		liveSessionId: liveSessionId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *LiveSessionsApiService) LiveSessionsGetLiveSessionPropertiesExecute(r ApiLiveSessionsGetLiveSessionPropertiesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsGetLiveSessionProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions/{liveSessionId}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"liveSessionId"+"}", url.PathEscape(parameterToString(r.liveSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveSessionsGetLiveSessionsRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	returnURL *string
	limit *int64
	offset *int64
	useCache *bool
	sort *[]string
	search *string
	activities *string
	fromTime *int64
	toTime *int64
	safe *string
}

// The returned URL.
func (r ApiLiveSessionsGetLiveSessionsRequest) ReturnURL(returnURL string) ApiLiveSessionsGetLiveSessionsRequest {
	r.returnURL = &returnURL
	return r
}

// Determines the number of lives sessions that are returned in the list. The maximum value is defined in the MaxRecords property in Options -&gt; Privileged Session Management -&gt; General Setting -&gt; Search Properties.
func (r ApiLiveSessionsGetLiveSessionsRequest) Limit(limit int64) ApiLiveSessionsGetLiveSessionsRequest {
	r.limit = &limit
	return r
}

// Determines which recording results will be returned, according to a specific place in the returned list. This value defines the recording&#39;s place in the list and how many results will be skipped.
func (r ApiLiveSessionsGetLiveSessionsRequest) Offset(offset int64) ApiLiveSessionsGetLiveSessionsRequest {
	r.offset = &offset
	return r
}

func (r ApiLiveSessionsGetLiveSessionsRequest) UseCache(useCache bool) ApiLiveSessionsGetLiveSessionsRequest {
	r.useCache = &useCache
	return r
}

// The sort can be done by each property on the recording file: RiskScore, FileName, SafeName, FolderName, PSMVaultUserName, FromIP, RemoteMachine, Client, Protocol, AccountUserName, AccountAddress, AccountPlatformID, PSMStartTime, TicketID. The sort can be in ascending or descending order. To sort in descending order, specify &#39; - &#39; (dash) before the recording property by which to sort.
func (r ApiLiveSessionsGetLiveSessionsRequest) Sort(sort []string) ApiLiveSessionsGetLiveSessionsRequest {
	r.sort = &sort
	return r
}

// Returns lives sessions that are filtered by properties that contain the specified search text.
func (r ApiLiveSessionsGetLiveSessionsRequest) Search(search string) ApiLiveSessionsGetLiveSessionsRequest {
	r.search = &search
	return r
}

// Returns lives sessions with specific activities.
func (r ApiLiveSessionsGetLiveSessionsRequest) Activities(activities string) ApiLiveSessionsGetLiveSessionsRequest {
	r.activities = &activities
	return r
}

// Returns lives sessions from a specific date.
func (r ApiLiveSessionsGetLiveSessionsRequest) FromTime(fromTime int64) ApiLiveSessionsGetLiveSessionsRequest {
	r.fromTime = &fromTime
	return r
}

// Returns lives sessions before a specific date.
func (r ApiLiveSessionsGetLiveSessionsRequest) ToTime(toTime int64) ApiLiveSessionsGetLiveSessionsRequest {
	r.toTime = &toTime
	return r
}

// Returns lives sessions that use accounts from a specific Safe.
func (r ApiLiveSessionsGetLiveSessionsRequest) Safe(safe string) ApiLiveSessionsGetLiveSessionsRequest {
	r.safe = &safe
	return r
}

func (r ApiLiveSessionsGetLiveSessionsRequest) Execute() (*LiveSession, *http.Response, error) {
	return r.ApiService.LiveSessionsGetLiveSessionsExecute(r)
}

/*
LiveSessionsGetLiveSessions Method for LiveSessionsGetLiveSessions

This method returns details of live sessions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveSessionsGetLiveSessionsRequest
*/
func (a *LiveSessionsApiService) LiveSessionsGetLiveSessions(ctx context.Context) ApiLiveSessionsGetLiveSessionsRequest {
	return ApiLiveSessionsGetLiveSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveSession
func (a *LiveSessionsApiService) LiveSessionsGetLiveSessionsExecute(r ApiLiveSessionsGetLiveSessionsRequest) (*LiveSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsGetLiveSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnURL != nil {
		localVarQueryParams.Add("returnURL", parameterToString(*r.returnURL, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.useCache != nil {
		localVarQueryParams.Add("useCache", parameterToString(*r.useCache, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.activities != nil {
		localVarQueryParams.Add("activities", parameterToString(*r.activities, ""))
	}
	if r.fromTime != nil {
		localVarQueryParams.Add("fromTime", parameterToString(*r.fromTime, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.safe != nil {
		localVarQueryParams.Add("safe", parameterToString(*r.safe, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveSessionsPSMAutoTerminationRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	liveSessionId string
}

func (r ApiLiveSessionsPSMAutoTerminationRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveSessionsPSMAutoTerminationExecute(r)
}

/*
LiveSessionsPSMAutoTermination Method for LiveSessionsPSMAutoTermination

This method terminates an active PSM session immediately.
This enables the system to terminate an active PSM session immediately to prevent high-risk activities.

In the PVWA system configuration, specify the following:
            
AllowPSMNotifications - Set Privileged Session Management &gt; General settings &gt; Server settings &gt; Live Session Monitoring settings &gt; AllowPSMNotifications to Yes to enable users to suspend active sessions.
Note: This parameter is not supported on PSMP and OPM sessions.
Terminating Active Sessions Users And Groups - Users need to be added as a user in the Terminating Active Sessions Users And Groups parameter.The default group is PSMLiveSessionTerminators.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveSessionId The unique ID of the PSM Active Session.
 @return ApiLiveSessionsPSMAutoTerminationRequest
*/
func (a *LiveSessionsApiService) LiveSessionsPSMAutoTermination(ctx context.Context, liveSessionId string) ApiLiveSessionsPSMAutoTerminationRequest {
	return ApiLiveSessionsPSMAutoTerminationRequest{
		ApiService: a,
		ctx: ctx,
		liveSessionId: liveSessionId,
	}
}

// Execute executes the request
func (a *LiveSessionsApiService) LiveSessionsPSMAutoTerminationExecute(r ApiLiveSessionsPSMAutoTerminationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsPSMAutoTermination")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions/{liveSessionId}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"liveSessionId"+"}", url.PathEscape(parameterToString(r.liveSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLiveSessionsPSMMonitorRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	liveSessionId string
}

func (r ApiLiveSessionsPSMMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveSessionsPSMMonitorExecute(r)
}

/*
LiveSessionsPSMMonitor Method for LiveSessionsPSMMonitor

This method returns connection data necessary to launch live monitoring of an active PSM session.
  
Note that the Accept header can be passed to receive the connection data as application/json

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveSessionId The unique ID of the PSM Active Session.
 @return ApiLiveSessionsPSMMonitorRequest
*/
func (a *LiveSessionsApiService) LiveSessionsPSMMonitor(ctx context.Context, liveSessionId string) ApiLiveSessionsPSMMonitorRequest {
	return ApiLiveSessionsPSMMonitorRequest{
		ApiService: a,
		ctx: ctx,
		liveSessionId: liveSessionId,
	}
}

// Execute executes the request
func (a *LiveSessionsApiService) LiveSessionsPSMMonitorExecute(r ApiLiveSessionsPSMMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsPSMMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions/{liveSessionId}/monitor"
	localVarPath = strings.Replace(localVarPath, "{"+"liveSessionId"+"}", url.PathEscape(parameterToString(r.liveSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLiveSessionsPSMSessionResumeRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	liveSessionId string
}

func (r ApiLiveSessionsPSMSessionResumeRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveSessionsPSMSessionResumeExecute(r)
}

/*
LiveSessionsPSMSessionResume Method for LiveSessionsPSMSessionResume

This method resume a suspended active PSM session and allow the privileged user to continue working with the session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveSessionId The unique ID of the PSM Active Session.
 @return ApiLiveSessionsPSMSessionResumeRequest
*/
func (a *LiveSessionsApiService) LiveSessionsPSMSessionResume(ctx context.Context, liveSessionId string) ApiLiveSessionsPSMSessionResumeRequest {
	return ApiLiveSessionsPSMSessionResumeRequest{
		ApiService: a,
		ctx: ctx,
		liveSessionId: liveSessionId,
	}
}

// Execute executes the request
func (a *LiveSessionsApiService) LiveSessionsPSMSessionResumeExecute(r ApiLiveSessionsPSMSessionResumeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsPSMSessionResume")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions/{liveSessionId}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"liveSessionId"+"}", url.PathEscape(parameterToString(r.liveSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLiveSessionsPSMSuspendRequest struct {
	ctx context.Context
	ApiService *LiveSessionsApiService
	liveSessionId string
}

func (r ApiLiveSessionsPSMSuspendRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveSessionsPSMSuspendExecute(r)
}

/*
LiveSessionsPSMSuspend Method for LiveSessionsPSMSuspend

This method suspend (prevents a user from interacting with an active PSM session) until a security manager resumes the session. 
Security teams can review the potentially risky session's audit trail to determine whether to allow the privileged user to continue to work with the session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param liveSessionId The unique ID of the PSM Active Session.
 @return ApiLiveSessionsPSMSuspendRequest
*/
func (a *LiveSessionsApiService) LiveSessionsPSMSuspend(ctx context.Context, liveSessionId string) ApiLiveSessionsPSMSuspendRequest {
	return ApiLiveSessionsPSMSuspendRequest{
		ApiService: a,
		ctx: ctx,
		liveSessionId: liveSessionId,
	}
}

// Execute executes the request
func (a *LiveSessionsApiService) LiveSessionsPSMSuspendExecute(r ApiLiveSessionsPSMSuspendRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveSessionsApiService.LiveSessionsPSMSuspend")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/LiveSessions/{liveSessionId}/suspend"
	localVarPath = strings.Replace(localVarPath, "{"+"liveSessionId"+"}", url.PathEscape(parameterToString(r.liveSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
