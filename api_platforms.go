/*
Privileged Access Security REST API

Display the PVWA REST APIs below for a description of how to use them and try them out. Access information about additional REST APIs through the online documentation.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PlatformsApiService PlatformsApi service
type PlatformsApiService service

type ApiPlatformsActivateGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsActivateGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsActivateGroupPlatformExecute(r)
}

/*
PlatformsActivateGroupPlatform Method for PlatformsActivateGroupPlatform

This method allows Vault Admins to activate a group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the group platform.
 @return ApiPlatformsActivateGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsActivateGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsActivateGroupPlatformRequest {
	return ApiPlatformsActivateGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsActivateGroupPlatformExecute(r ApiPlatformsActivateGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsActivateGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Groups/{platformID}/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsActivateRotationalGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsActivateRotationalGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsActivateRotationalGroupPlatformExecute(r)
}

/*
PlatformsActivateRotationalGroupPlatform Method for PlatformsActivateRotationalGroupPlatform

This method allows Vault Admins to activate a rotational group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the rotational group platform.
 @return ApiPlatformsActivateRotationalGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsActivateRotationalGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsActivateRotationalGroupPlatformRequest {
	return ApiPlatformsActivateRotationalGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsActivateRotationalGroupPlatformExecute(r ApiPlatformsActivateRotationalGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsActivateRotationalGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/RotationalGroups/{platformID}/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsActivateTargetPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsActivateTargetPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsActivateTargetPlatformExecute(r)
}

/*
PlatformsActivateTargetPlatform Method for PlatformsActivateTargetPlatform

This method allows Vault Admins to activate a target platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the target platform.
 @return ApiPlatformsActivateTargetPlatformRequest
*/
func (a *PlatformsApiService) PlatformsActivateTargetPlatform(ctx context.Context, platformID int64) ApiPlatformsActivateTargetPlatformRequest {
	return ApiPlatformsActivateTargetPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsActivateTargetPlatformExecute(r ApiPlatformsActivateTargetPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsActivateTargetPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/{platformID}/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDeactivateGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsDeactivateGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDeactivateGroupPlatformExecute(r)
}

/*
PlatformsDeactivateGroupPlatform Method for PlatformsDeactivateGroupPlatform

This method allows Vault Admins to deactivate a group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the group platform.
 @return ApiPlatformsDeactivateGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDeactivateGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsDeactivateGroupPlatformRequest {
	return ApiPlatformsDeactivateGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDeactivateGroupPlatformExecute(r ApiPlatformsDeactivateGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDeactivateGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Groups/{platformID}/deactivate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDeactivateRotationalGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsDeactivateRotationalGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDeactivateRotationalGroupPlatformExecute(r)
}

/*
PlatformsDeactivateRotationalGroupPlatform Method for PlatformsDeactivateRotationalGroupPlatform

This method allows Vault Admins to deactivate a rotational group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the rotational group platform.
 @return ApiPlatformsDeactivateRotationalGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDeactivateRotationalGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsDeactivateRotationalGroupPlatformRequest {
	return ApiPlatformsDeactivateRotationalGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDeactivateRotationalGroupPlatformExecute(r ApiPlatformsDeactivateRotationalGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDeactivateRotationalGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/RotationalGroups/{platformID}/deactivate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDeactivateTargetPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsDeactivateTargetPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDeactivateTargetPlatformExecute(r)
}

/*
PlatformsDeactivateTargetPlatform Method for PlatformsDeactivateTargetPlatform

This method allows Vault Admins to deactivate a target platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the target platform.
 @return ApiPlatformsDeactivateTargetPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDeactivateTargetPlatform(ctx context.Context, platformID int64) ApiPlatformsDeactivateTargetPlatformRequest {
	return ApiPlatformsDeactivateTargetPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDeactivateTargetPlatformExecute(r ApiPlatformsDeactivateTargetPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDeactivateTargetPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/{platformID}/deactivate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDeleteDependentPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsDeleteDependentPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDeleteDependentPlatformExecute(r)
}

/*
PlatformsDeleteDependentPlatform Method for PlatformsDeleteDependentPlatform

This method allows Vault Admins to delete a dependent platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the dependent platform.
 @return ApiPlatformsDeleteDependentPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDeleteDependentPlatform(ctx context.Context, platformID int64) ApiPlatformsDeleteDependentPlatformRequest {
	return ApiPlatformsDeleteDependentPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDeleteDependentPlatformExecute(r ApiPlatformsDeleteDependentPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDeleteDependentPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Dependents/{platformID}"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDeleteGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsDeleteGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDeleteGroupPlatformExecute(r)
}

/*
PlatformsDeleteGroupPlatform Method for PlatformsDeleteGroupPlatform

This method allows Vault Admins to delete a group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the group platform.
 @return ApiPlatformsDeleteGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDeleteGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsDeleteGroupPlatformRequest {
	return ApiPlatformsDeleteGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDeleteGroupPlatformExecute(r ApiPlatformsDeleteGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDeleteGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Groups/{platformID}"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDeleteRotationalGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsDeleteRotationalGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDeleteRotationalGroupPlatformExecute(r)
}

/*
PlatformsDeleteRotationalGroupPlatform Method for PlatformsDeleteRotationalGroupPlatform

This method allows Vault Admins to delete a rotational group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the rotational group platform.
 @return ApiPlatformsDeleteRotationalGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDeleteRotationalGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsDeleteRotationalGroupPlatformRequest {
	return ApiPlatformsDeleteRotationalGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDeleteRotationalGroupPlatformExecute(r ApiPlatformsDeleteRotationalGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDeleteRotationalGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/RotationalGroups/{platformID}"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDeleteTargetPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsDeleteTargetPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDeleteTargetPlatformExecute(r)
}

/*
PlatformsDeleteTargetPlatform Method for PlatformsDeleteTargetPlatform

This method allows Vault Admins to delete a target platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the target platform.
 @return ApiPlatformsDeleteTargetPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDeleteTargetPlatform(ctx context.Context, platformID int64) ApiPlatformsDeleteTargetPlatformRequest {
	return ApiPlatformsDeleteTargetPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDeleteTargetPlatformExecute(r ApiPlatformsDeleteTargetPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDeleteTargetPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/{platformID}"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDuplicateDependentPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
	duplicatePlatformDetails *DuplicatePlatform
}

// The details of the new platform.
func (r ApiPlatformsDuplicateDependentPlatformRequest) DuplicatePlatformDetails(duplicatePlatformDetails DuplicatePlatform) ApiPlatformsDuplicateDependentPlatformRequest {
	r.duplicatePlatformDetails = &duplicatePlatformDetails
	return r
}

func (r ApiPlatformsDuplicateDependentPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDuplicateDependentPlatformExecute(r)
}

/*
PlatformsDuplicateDependentPlatform Method for PlatformsDuplicateDependentPlatform

This method allows Vault Admins to duplicate a dependent platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the source dependent platform from which to duplicate
 @return ApiPlatformsDuplicateDependentPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDuplicateDependentPlatform(ctx context.Context, platformID int64) ApiPlatformsDuplicateDependentPlatformRequest {
	return ApiPlatformsDuplicateDependentPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDuplicateDependentPlatformExecute(r ApiPlatformsDuplicateDependentPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDuplicateDependentPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Dependents/{platformID}/Duplicate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.duplicatePlatformDetails == nil {
		return localVarReturnValue, nil, reportError("duplicatePlatformDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.duplicatePlatformDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDuplicateGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
	duplicatePlatformDetails *DuplicatePlatform
}

// The details of the new platform.
func (r ApiPlatformsDuplicateGroupPlatformRequest) DuplicatePlatformDetails(duplicatePlatformDetails DuplicatePlatform) ApiPlatformsDuplicateGroupPlatformRequest {
	r.duplicatePlatformDetails = &duplicatePlatformDetails
	return r
}

func (r ApiPlatformsDuplicateGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDuplicateGroupPlatformExecute(r)
}

/*
PlatformsDuplicateGroupPlatform Method for PlatformsDuplicateGroupPlatform

This method allows Vault Admins to duplicate a group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the source group platform from which to duplicate
 @return ApiPlatformsDuplicateGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDuplicateGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsDuplicateGroupPlatformRequest {
	return ApiPlatformsDuplicateGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDuplicateGroupPlatformExecute(r ApiPlatformsDuplicateGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDuplicateGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Groups/{platformID}/Duplicate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.duplicatePlatformDetails == nil {
		return localVarReturnValue, nil, reportError("duplicatePlatformDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.duplicatePlatformDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDuplicateRotationalGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
	duplicatePlatformDetails *DuplicatePlatform
}

// The details of the new platform.
func (r ApiPlatformsDuplicateRotationalGroupPlatformRequest) DuplicatePlatformDetails(duplicatePlatformDetails DuplicatePlatform) ApiPlatformsDuplicateRotationalGroupPlatformRequest {
	r.duplicatePlatformDetails = &duplicatePlatformDetails
	return r
}

func (r ApiPlatformsDuplicateRotationalGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDuplicateRotationalGroupPlatformExecute(r)
}

/*
PlatformsDuplicateRotationalGroupPlatform Method for PlatformsDuplicateRotationalGroupPlatform

This method allows Vault Admins to duplicate a rotational group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the source rotational group platform from which to duplicate
 @return ApiPlatformsDuplicateRotationalGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDuplicateRotationalGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsDuplicateRotationalGroupPlatformRequest {
	return ApiPlatformsDuplicateRotationalGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDuplicateRotationalGroupPlatformExecute(r ApiPlatformsDuplicateRotationalGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDuplicateRotationalGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/RotationalGroups/{platformID}/Duplicate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.duplicatePlatformDetails == nil {
		return localVarReturnValue, nil, reportError("duplicatePlatformDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.duplicatePlatformDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsDuplicateTargetPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
	duplicatePlatformDetails *DuplicatePlatform
}

// The details of the new platform.
func (r ApiPlatformsDuplicateTargetPlatformRequest) DuplicatePlatformDetails(duplicatePlatformDetails DuplicatePlatform) ApiPlatformsDuplicateTargetPlatformRequest {
	r.duplicatePlatformDetails = &duplicatePlatformDetails
	return r
}

func (r ApiPlatformsDuplicateTargetPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsDuplicateTargetPlatformExecute(r)
}

/*
PlatformsDuplicateTargetPlatform Method for PlatformsDuplicateTargetPlatform

This method allows Vault Admins to duplicate a target platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the source target platform from which to duplicate
 @return ApiPlatformsDuplicateTargetPlatformRequest
*/
func (a *PlatformsApiService) PlatformsDuplicateTargetPlatform(ctx context.Context, platformID int64) ApiPlatformsDuplicateTargetPlatformRequest {
	return ApiPlatformsDuplicateTargetPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsDuplicateTargetPlatformExecute(r ApiPlatformsDuplicateTargetPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsDuplicateTargetPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/{platformID}/Duplicate"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.duplicatePlatformDetails == nil {
		return localVarReturnValue, nil, reportError("duplicatePlatformDetails is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.duplicatePlatformDetails
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsExportRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID string
}

func (r ApiPlatformsExportRequest) Execute() (*http.Response, error) {
	return r.ApiService.PlatformsExportExecute(r)
}

/*
PlatformsExport Method for PlatformsExport

This method enables you to export a platform to a zip file in order to import it to a different Vault environment.
Note: This method returns a ZIP file that contains only the CPM Policy files and the PVWA Settings.
If there are additional CPM plug-in files, they must be added manually by the user to the ZIP file before importing.
This method can be used by members of the Vault Admin group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID
 @return ApiPlatformsExportRequest
*/
func (a *PlatformsApiService) PlatformsExport(ctx context.Context, platformID string) ApiPlatformsExportRequest {
	return ApiPlatformsExportRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
func (a *PlatformsApiService) PlatformsExportExecute(r ApiPlatformsExportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsExport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/{PlatformID}/Export"
	localVarPath = strings.Replace(localVarPath, "{"+"PlatformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlatformsExportDependentPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsExportDependentPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsExportDependentPlatformExecute(r)
}

/*
PlatformsExportDependentPlatform Method for PlatformsExportDependentPlatform

This method allows Vault Admins to export a dependent platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the dependent platform.
 @return ApiPlatformsExportDependentPlatformRequest
*/
func (a *PlatformsApiService) PlatformsExportDependentPlatform(ctx context.Context, platformID int64) ApiPlatformsExportDependentPlatformRequest {
	return ApiPlatformsExportDependentPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsExportDependentPlatformExecute(r ApiPlatformsExportDependentPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsExportDependentPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Dependents/{platformID}/Export"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsExportGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsExportGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsExportGroupPlatformExecute(r)
}

/*
PlatformsExportGroupPlatform Method for PlatformsExportGroupPlatform

This method allows Vault Admins to export a group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the group platform.
 @return ApiPlatformsExportGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsExportGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsExportGroupPlatformRequest {
	return ApiPlatformsExportGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsExportGroupPlatformExecute(r ApiPlatformsExportGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsExportGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Groups/{platformID}/Export"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsExportRotationalGroupPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsExportRotationalGroupPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsExportRotationalGroupPlatformExecute(r)
}

/*
PlatformsExportRotationalGroupPlatform Method for PlatformsExportRotationalGroupPlatform

This method allows Vault Admins to export a rotational group platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the rotational group platform.
 @return ApiPlatformsExportRotationalGroupPlatformRequest
*/
func (a *PlatformsApiService) PlatformsExportRotationalGroupPlatform(ctx context.Context, platformID int64) ApiPlatformsExportRotationalGroupPlatformRequest {
	return ApiPlatformsExportRotationalGroupPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsExportRotationalGroupPlatformExecute(r ApiPlatformsExportRotationalGroupPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsExportRotationalGroupPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/RotationalGroups/{platformID}/Export"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsExportTargetPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsExportTargetPlatformRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PlatformsExportTargetPlatformExecute(r)
}

/*
PlatformsExportTargetPlatform Method for PlatformsExportTargetPlatform

This method allows Vault Admins to export a target platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the target platform.
 @return ApiPlatformsExportTargetPlatformRequest
*/
func (a *PlatformsApiService) PlatformsExportTargetPlatform(ctx context.Context, platformID int64) ApiPlatformsExportTargetPlatformRequest {
	return ApiPlatformsExportTargetPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PlatformsApiService) PlatformsExportTargetPlatformExecute(r ApiPlatformsExportTargetPlatformRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsExportTargetPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/{platformID}/Export"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetDependentPlaformsRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	search *string
}

func (r ApiPlatformsGetDependentPlaformsRequest) Search(search string) ApiPlatformsGetDependentPlaformsRequest {
	r.search = &search
	return r
}

func (r ApiPlatformsGetDependentPlaformsRequest) Execute() ([]DependentPlatform, *http.Response, error) {
	return r.ApiService.PlatformsGetDependentPlaformsExecute(r)
}

/*
PlatformsGetDependentPlaforms Method for PlatformsGetDependentPlaforms

This method allows users to retrieve basic information of all existing dependent platforms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlatformsGetDependentPlaformsRequest
*/
func (a *PlatformsApiService) PlatformsGetDependentPlaforms(ctx context.Context) ApiPlatformsGetDependentPlaformsRequest {
	return ApiPlatformsGetDependentPlaformsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DependentPlatform
func (a *PlatformsApiService) PlatformsGetDependentPlaformsExecute(r ApiPlatformsGetDependentPlaformsRequest) ([]DependentPlatform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DependentPlatform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetDependentPlaforms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Dependents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetGroupPlaformsRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	search *string
}

func (r ApiPlatformsGetGroupPlaformsRequest) Search(search string) ApiPlatformsGetGroupPlaformsRequest {
	r.search = &search
	return r
}

func (r ApiPlatformsGetGroupPlaformsRequest) Execute() ([]GroupPlatform, *http.Response, error) {
	return r.ApiService.PlatformsGetGroupPlaformsExecute(r)
}

/*
PlatformsGetGroupPlaforms Method for PlatformsGetGroupPlaforms

This method allows users to retrieve basic information of all existing group platforms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlatformsGetGroupPlaformsRequest
*/
func (a *PlatformsApiService) PlatformsGetGroupPlaforms(ctx context.Context) ApiPlatformsGetGroupPlaformsRequest {
	return ApiPlatformsGetGroupPlaformsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GroupPlatform
func (a *PlatformsApiService) PlatformsGetGroupPlaformsExecute(r ApiPlatformsGetGroupPlaformsRequest) ([]GroupPlatform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupPlatform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetGroupPlaforms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetPlaformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	id string
}

func (r ApiPlatformsGetPlaformRequest) Execute() (*Platform, *http.Response, error) {
	return r.ApiService.PlatformsGetPlaformExecute(r)
}

/*
PlatformsGetPlaform Method for PlatformsGetPlaform

This method retrieves details of a specified platform from the Vault.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The unique ID of the platform.
 @return ApiPlatformsGetPlaformRequest
*/
func (a *PlatformsApiService) PlatformsGetPlaform(ctx context.Context, id string) ApiPlatformsGetPlaformRequest {
	return ApiPlatformsGetPlaformRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Platform
func (a *PlatformsApiService) PlatformsGetPlaformExecute(r ApiPlatformsGetPlaformRequest) (*Platform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Platform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetPlaform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetPlatformsRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	active *bool
	platformType *int32
	search *string
	systemType *string
}

func (r ApiPlatformsGetPlatformsRequest) Active(active bool) ApiPlatformsGetPlatformsRequest {
	r.active = &active
	return r
}

func (r ApiPlatformsGetPlatformsRequest) PlatformType(platformType int32) ApiPlatformsGetPlatformsRequest {
	r.platformType = &platformType
	return r
}

// The search will be by Platform ID or Platform Name.
func (r ApiPlatformsGetPlatformsRequest) Search(search string) ApiPlatformsGetPlatformsRequest {
	r.search = &search
	return r
}

func (r ApiPlatformsGetPlatformsRequest) SystemType(systemType string) ApiPlatformsGetPlatformsRequest {
	r.systemType = &systemType
	return r
}

func (r ApiPlatformsGetPlatformsRequest) Execute() ([]PlatformModel, *http.Response, error) {
	return r.ApiService.PlatformsGetPlatformsExecute(r)
}

/*
PlatformsGetPlatforms Method for PlatformsGetPlatforms

This method will return all existing account platforms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlatformsGetPlatformsRequest
*/
func (a *PlatformsApiService) PlatformsGetPlatforms(ctx context.Context) ApiPlatformsGetPlatformsRequest {
	return ApiPlatformsGetPlatformsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PlatformModel
func (a *PlatformsApiService) PlatformsGetPlatformsExecute(r ApiPlatformsGetPlatformsRequest) ([]PlatformModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlatformModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetPlatforms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.platformType != nil {
		localVarQueryParams.Add("platformType", parameterToString(*r.platformType, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.systemType != nil {
		localVarQueryParams.Add("systemType", parameterToString(*r.systemType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetPrivilegedSessionManagementDetailsRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
}

func (r ApiPlatformsGetPrivilegedSessionManagementDetailsRequest) Execute() (*PrivilegedSessionManagement, *http.Response, error) {
	return r.ApiService.PlatformsGetPrivilegedSessionManagementDetailsExecute(r)
}

/*
PlatformsGetPrivilegedSessionManagementDetails Method for PlatformsGetPrivilegedSessionManagementDetails

This method allows Vault Admins to retrieve the PSM Policy Section of a target platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the target platform.
 @return ApiPlatformsGetPrivilegedSessionManagementDetailsRequest
*/
func (a *PlatformsApiService) PlatformsGetPrivilegedSessionManagementDetails(ctx context.Context, platformID int64) ApiPlatformsGetPrivilegedSessionManagementDetailsRequest {
	return ApiPlatformsGetPrivilegedSessionManagementDetailsRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return PrivilegedSessionManagement
func (a *PlatformsApiService) PlatformsGetPrivilegedSessionManagementDetailsExecute(r ApiPlatformsGetPrivilegedSessionManagementDetailsRequest) (*PrivilegedSessionManagement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrivilegedSessionManagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetPrivilegedSessionManagementDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/{platformID}/PrivilegedSessionManagement"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetRotationalGroupPlaformsRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	search *string
}

func (r ApiPlatformsGetRotationalGroupPlaformsRequest) Search(search string) ApiPlatformsGetRotationalGroupPlaformsRequest {
	r.search = &search
	return r
}

func (r ApiPlatformsGetRotationalGroupPlaformsRequest) Execute() ([]RotationalGroupPlatform, *http.Response, error) {
	return r.ApiService.PlatformsGetRotationalGroupPlaformsExecute(r)
}

/*
PlatformsGetRotationalGroupPlaforms Method for PlatformsGetRotationalGroupPlaforms

This method allows users to retrieve basic information of all existing rotational group platforms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlatformsGetRotationalGroupPlaformsRequest
*/
func (a *PlatformsApiService) PlatformsGetRotationalGroupPlaforms(ctx context.Context) ApiPlatformsGetRotationalGroupPlaformsRequest {
	return ApiPlatformsGetRotationalGroupPlaformsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RotationalGroupPlatform
func (a *PlatformsApiService) PlatformsGetRotationalGroupPlaformsExecute(r ApiPlatformsGetRotationalGroupPlaformsRequest) ([]RotationalGroupPlatform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RotationalGroupPlatform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetRotationalGroupPlaforms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/RotationalGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetSafesByPlatformRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformId string
	safe *string
}

func (r ApiPlatformsGetSafesByPlatformRequest) Safe(safe string) ApiPlatformsGetSafesByPlatformRequest {
	r.safe = &safe
	return r
}

func (r ApiPlatformsGetSafesByPlatformRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.PlatformsGetSafesByPlatformExecute(r)
}

/*
PlatformsGetSafesByPlatform Method for PlatformsGetSafesByPlatform

This method gets platform's safes.
This method can be used by members of the Vault Admin group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformId
 @return ApiPlatformsGetSafesByPlatformRequest
*/
func (a *PlatformsApiService) PlatformsGetSafesByPlatform(ctx context.Context, platformId string) ApiPlatformsGetSafesByPlatformRequest {
	return ApiPlatformsGetSafesByPlatformRequest{
		ApiService: a,
		ctx: ctx,
		platformId: platformId,
	}
}

// Execute executes the request
//  @return []string
func (a *PlatformsApiService) PlatformsGetSafesByPlatformExecute(r ApiPlatformsGetSafesByPlatformRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetSafesByPlatform")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/{PlatformId}/Safes"
	localVarPath = strings.Replace(localVarPath, "{"+"PlatformId"+"}", url.PathEscape(parameterToString(r.platformId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.safe != nil {
		localVarQueryParams.Add("safe", parameterToString(*r.safe, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetSystemTypesRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
}

func (r ApiPlatformsGetSystemTypesRequest) Execute() ([]SystemType, *http.Response, error) {
	return r.ApiService.PlatformsGetSystemTypesExecute(r)
}

/*
PlatformsGetSystemTypes Method for PlatformsGetSystemTypes

This method allows users to retrieve all basic information on all existing system types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlatformsGetSystemTypesRequest
*/
func (a *PlatformsApiService) PlatformsGetSystemTypes(ctx context.Context) ApiPlatformsGetSystemTypesRequest {
	return ApiPlatformsGetSystemTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SystemType
func (a *PlatformsApiService) PlatformsGetSystemTypesExecute(r ApiPlatformsGetSystemTypesRequest) ([]SystemType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SystemType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetSystemTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/SystemTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsGetTargetPlaformsRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	filter *string
	search *string
}

func (r ApiPlatformsGetTargetPlaformsRequest) Filter(filter string) ApiPlatformsGetTargetPlaformsRequest {
	r.filter = &filter
	return r
}

func (r ApiPlatformsGetTargetPlaformsRequest) Search(search string) ApiPlatformsGetTargetPlaformsRequest {
	r.search = &search
	return r
}

func (r ApiPlatformsGetTargetPlaformsRequest) Execute() ([]TargetPlatform, *http.Response, error) {
	return r.ApiService.PlatformsGetTargetPlaformsExecute(r)
}

/*
PlatformsGetTargetPlaforms Method for PlatformsGetTargetPlaforms

This method allows users to retrieve basic information of all existing target platforms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlatformsGetTargetPlaformsRequest
*/
func (a *PlatformsApiService) PlatformsGetTargetPlaforms(ctx context.Context) ApiPlatformsGetTargetPlaformsRequest {
	return ApiPlatformsGetTargetPlaformsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TargetPlatform
func (a *PlatformsApiService) PlatformsGetTargetPlaformsExecute(r ApiPlatformsGetTargetPlaformsRequest) ([]TargetPlatform, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TargetPlatform
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsGetTargetPlaforms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsImportRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	importPlatform *ImportPlatformData
}

// The ZIP file containing the platform and additional configuration parameters.
func (r ApiPlatformsImportRequest) ImportPlatform(importPlatform ImportPlatformData) ApiPlatformsImportRequest {
	r.importPlatform = &importPlatform
	return r
}

func (r ApiPlatformsImportRequest) Execute() (*ImportPlatformResponse, *http.Response, error) {
	return r.ApiService.PlatformsImportExecute(r)
}

/*
PlatformsImport Method for PlatformsImport

This method allows administrators to import a new platform.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlatformsImportRequest
*/
func (a *PlatformsApiService) PlatformsImport(ctx context.Context) ApiPlatformsImportRequest {
	return ApiPlatformsImportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImportPlatformResponse
func (a *PlatformsApiService) PlatformsImportExecute(r ApiPlatformsImportRequest) (*ImportPlatformResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImportPlatformResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.importPlatform == nil {
		return localVarReturnValue, nil, reportError("importPlatform is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importPlatform
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlatformsSetPrivilegedSessionManagementDetailsRequest struct {
	ctx context.Context
	ApiService *PlatformsApiService
	platformID int64
	privilegedSessionManagement *PrivilegedSessionManagement
}

// Unique ID of the psm server and list of connectors
func (r ApiPlatformsSetPrivilegedSessionManagementDetailsRequest) PrivilegedSessionManagement(privilegedSessionManagement PrivilegedSessionManagement) ApiPlatformsSetPrivilegedSessionManagementDetailsRequest {
	r.privilegedSessionManagement = &privilegedSessionManagement
	return r
}

func (r ApiPlatformsSetPrivilegedSessionManagementDetailsRequest) Execute() (*PrivilegedSessionManagement, *http.Response, error) {
	return r.ApiService.PlatformsSetPrivilegedSessionManagementDetailsExecute(r)
}

/*
PlatformsSetPrivilegedSessionManagementDetails Method for PlatformsSetPrivilegedSessionManagementDetails

This method allows Vault Admins to update the PSM policy section of a target platform.
To run this web service, the user must be a member of the Vault Admins group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformID Unique ID of the target platform.
 @return ApiPlatformsSetPrivilegedSessionManagementDetailsRequest
*/
func (a *PlatformsApiService) PlatformsSetPrivilegedSessionManagementDetails(ctx context.Context, platformID int64) ApiPlatformsSetPrivilegedSessionManagementDetailsRequest {
	return ApiPlatformsSetPrivilegedSessionManagementDetailsRequest{
		ApiService: a,
		ctx: ctx,
		platformID: platformID,
	}
}

// Execute executes the request
//  @return PrivilegedSessionManagement
func (a *PlatformsApiService) PlatformsSetPrivilegedSessionManagementDetailsExecute(r ApiPlatformsSetPrivilegedSessionManagementDetailsRequest) (*PrivilegedSessionManagement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrivilegedSessionManagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlatformsApiService.PlatformsSetPrivilegedSessionManagementDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Platforms/Targets/{platformID}/PrivilegedSessionManagement"
	localVarPath = strings.Replace(localVarPath, "{"+"platformID"+"}", url.PathEscape(parameterToString(r.platformID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.privilegedSessionManagement == nil {
		return localVarReturnValue, nil, reportError("privilegedSessionManagement is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.privilegedSessionManagement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
