/*
Privileged Access Security REST API

Display the PVWA REST APIs below for a description of how to use them and try them out. Access information about additional REST APIs through the online documentation.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SafesApiService SafesApi service
type SafesApiService service

type ApiSafesAddSafeRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	addSafeRequest *AddSafeRequest
}

func (r ApiSafesAddSafeRequest) AddSafeRequest(addSafeRequest AddSafeRequest) ApiSafesAddSafeRequest {
	r.addSafeRequest = &addSafeRequest
	return r
}

func (r ApiSafesAddSafeRequest) Execute() (*AddSafeResponse, *http.Response, error) {
	return r.ApiService.SafesAddSafeExecute(r)
}

/*
SafesAddSafe Method for SafesAddSafe

This method adds a new Safe to the Vault.
The user who runs this web service requires Add Safes permission in the Vault.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSafesAddSafeRequest
*/
func (a *SafesApiService) SafesAddSafe(ctx context.Context) ApiSafesAddSafeRequest {
	return ApiSafesAddSafeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AddSafeResponse
func (a *SafesApiService) SafesAddSafeExecute(r ApiSafesAddSafeRequest) (*AddSafeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddSafeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesAddSafe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addSafeRequest == nil {
		return localVarReturnValue, nil, reportError("addSafeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addSafeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesAddSafeMemberRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
	addSafeMemberRequestBody *AddSafeMemberRequestBody
}

func (r ApiSafesAddSafeMemberRequest) AddSafeMemberRequestBody(addSafeMemberRequestBody AddSafeMemberRequestBody) ApiSafesAddSafeMemberRequest {
	r.addSafeMemberRequestBody = &addSafeMemberRequestBody
	return r
}

func (r ApiSafesAddSafeMemberRequest) Execute() (*AddSafeMemberResponse, *http.Response, error) {
	return r.ApiService.SafesAddSafeMemberExecute(r)
}

/*
SafesAddSafeMember Method for SafesAddSafeMember

This method adds an existing user as a Safe member.
The user who run this web service requires Manage and View Members permissions in the Safe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the Safe used when calling Safe APIs.
 @return ApiSafesAddSafeMemberRequest
*/
func (a *SafesApiService) SafesAddSafeMember(ctx context.Context, safeUrlId string) ApiSafesAddSafeMemberRequest {
	return ApiSafesAddSafeMemberRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
	}
}

// Execute executes the request
//  @return AddSafeMemberResponse
func (a *SafesApiService) SafesAddSafeMemberExecute(r ApiSafesAddSafeMemberRequest) (*AddSafeMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddSafeMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesAddSafeMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addSafeMemberRequestBody == nil {
		return localVarReturnValue, nil, reportError("addSafeMemberRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addSafeMemberRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesDeleteSafeRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
}

func (r ApiSafesDeleteSafeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SafesDeleteSafeExecute(r)
}

/*
SafesDeleteSafe Method for SafesDeleteSafe

This method deletes a safe from the Vault.
The user who runs this web service requires Manage Safe permission on the required Safe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the Safe.
 @return ApiSafesDeleteSafeRequest
*/
func (a *SafesApiService) SafesDeleteSafe(ctx context.Context, safeUrlId string) ApiSafesDeleteSafeRequest {
	return ApiSafesDeleteSafeRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SafesApiService) SafesDeleteSafeExecute(r ApiSafesDeleteSafeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesDeleteSafe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesDeleteSafeMemberRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
	memberName string
}

func (r ApiSafesDeleteSafeMemberRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SafesDeleteSafeMemberExecute(r)
}

/*
SafesDeleteSafeMember Method for SafesDeleteSafeMember

This method removes a specific member from a Safe.
The user who run this web service requires Manage Safe Members permission on the Safe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the Safe from which to delete the member.
 @param memberName The name of the Safe member to delete from the list of Safe members.
 @return ApiSafesDeleteSafeMemberRequest
*/
func (a *SafesApiService) SafesDeleteSafeMember(ctx context.Context, safeUrlId string, memberName string) ApiSafesDeleteSafeMemberRequest {
	return ApiSafesDeleteSafeMemberRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
		memberName: memberName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SafesApiService) SafesDeleteSafeMemberExecute(r ApiSafesDeleteSafeMemberRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesDeleteSafeMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}/members/{memberName}"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"memberName"+"}", url.PathEscape(parameterToString(r.memberName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesGetGroupsRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeName string
}

func (r ApiSafesGetGroupsRequest) Execute() (*AccountGroup, *http.Response, error) {
	return r.ApiService.SafesGetGroupsExecute(r)
}

/*
SafesGetGroups Method for SafesGetGroups

This method returns all the existing account groups in a specific Safe. The user performing this task must have the following permissions in the Safe:
List Accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeName The name of the Safe where the account groups are.
 @return ApiSafesGetGroupsRequest
*/
func (a *SafesApiService) SafesGetGroups(ctx context.Context, safeName string) ApiSafesGetGroupsRequest {
	return ApiSafesGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
		safeName: safeName,
	}
}

// Execute executes the request
//  @return AccountGroup
func (a *SafesApiService) SafesGetGroupsExecute(r ApiSafesGetGroupsRequest) (*AccountGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesGetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeName}/accountgroups"
	localVarPath = strings.Replace(localVarPath, "{"+"safeName"+"}", url.PathEscape(parameterToString(r.safeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesGetSafeDetailsRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
	includeAccounts *bool
	useCache *bool
}

// Whether or not to return accounts for each Safe as part of the response. If not sent, the value will be False.
func (r ApiSafesGetSafeDetailsRequest) IncludeAccounts(includeAccounts bool) ApiSafesGetSafeDetailsRequest {
	r.includeAccounts = &includeAccounts
	return r
}

// Whether to retrieve from session or not.
func (r ApiSafesGetSafeDetailsRequest) UseCache(useCache bool) ApiSafesGetSafeDetailsRequest {
	r.useCache = &useCache
	return r
}

func (r ApiSafesGetSafeDetailsRequest) Execute() (*GetSafeDetailsResponse, *http.Response, error) {
	return r.ApiService.SafesGetSafeDetailsExecute(r)
}

/*
SafesGetSafeDetails Method for SafesGetSafeDetails

This method returns information about a specific Safe in the Vault.
The user who runs this web service must be a member of the Safe in the Vault that is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the Safe.
 @return ApiSafesGetSafeDetailsRequest
*/
func (a *SafesApiService) SafesGetSafeDetails(ctx context.Context, safeUrlId string) ApiSafesGetSafeDetailsRequest {
	return ApiSafesGetSafeDetailsRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
	}
}

// Execute executes the request
//  @return GetSafeDetailsResponse
func (a *SafesApiService) SafesGetSafeDetailsExecute(r ApiSafesGetSafeDetailsRequest) (*GetSafeDetailsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSafeDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesGetSafeDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAccounts != nil {
		localVarQueryParams.Add("includeAccounts", parameterToString(*r.includeAccounts, ""))
	}
	if r.useCache != nil {
		localVarQueryParams.Add("useCache", parameterToString(*r.useCache, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesGetSafeMemberRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
	memberName string
	useCache *bool
}

// Whether to retrieve from session or not.
func (r ApiSafesGetSafeMemberRequest) UseCache(useCache bool) ApiSafesGetSafeMemberRequest {
	r.useCache = &useCache
	return r
}

func (r ApiSafesGetSafeMemberRequest) Execute() (*GetSafeMemberResponse, *http.Response, error) {
	return r.ApiService.SafesGetSafeMemberExecute(r)
}

/*
SafesGetSafeMember Method for SafesGetSafeMember

This method returns a member of a Safe.
To run this web service, the user must have View Safe Members permission for the Safe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the Safe used when calling Safe APIs.
 @param memberName The Vault user name, Domain user name or group name of the Safe member.
 @return ApiSafesGetSafeMemberRequest
*/
func (a *SafesApiService) SafesGetSafeMember(ctx context.Context, safeUrlId string, memberName string) ApiSafesGetSafeMemberRequest {
	return ApiSafesGetSafeMemberRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
		memberName: memberName,
	}
}

// Execute executes the request
//  @return GetSafeMemberResponse
func (a *SafesApiService) SafesGetSafeMemberExecute(r ApiSafesGetSafeMemberRequest) (*GetSafeMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSafeMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesGetSafeMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}/members/{memberName}"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"memberName"+"}", url.PathEscape(parameterToString(r.memberName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useCache != nil {
		localVarQueryParams.Add("useCache", parameterToString(*r.useCache, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesGetSafeMembersRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
	limit *int64
	offset *int64
	useCache *bool
	sort *[]string
	search *string
	filter *string
}

func (r ApiSafesGetSafeMembersRequest) Limit(limit int64) ApiSafesGetSafeMembersRequest {
	r.limit = &limit
	return r
}

func (r ApiSafesGetSafeMembersRequest) Offset(offset int64) ApiSafesGetSafeMembersRequest {
	r.offset = &offset
	return r
}

func (r ApiSafesGetSafeMembersRequest) UseCache(useCache bool) ApiSafesGetSafeMembersRequest {
	r.useCache = &useCache
	return r
}

func (r ApiSafesGetSafeMembersRequest) Sort(sort []string) ApiSafesGetSafeMembersRequest {
	r.sort = &sort
	return r
}

func (r ApiSafesGetSafeMembersRequest) Search(search string) ApiSafesGetSafeMembersRequest {
	r.search = &search
	return r
}

// &lt;para&gt;Filtering according to REST standard. &lt;/para&gt;  &lt;para&gt;memberType - Return only members of single type (user or group)&lt;/para&gt;  &lt;para&gt;membershipExpired - Return only members that have or don&#39;t have an expired membership&lt;/para&gt;  &lt;para&gt;includePredefinedUsers - Include predefined users in the returned list.&lt;/para&gt;
func (r ApiSafesGetSafeMembersRequest) Filter(filter string) ApiSafesGetSafeMembersRequest {
	r.filter = &filter
	return r
}

func (r ApiSafesGetSafeMembersRequest) Execute() (*SafeMemberResponse, *http.Response, error) {
	return r.ApiService.SafesGetSafeMembersExecute(r)
}

/*
SafesGetSafeMembers Method for SafesGetSafeMembers

This method returns the list of members of a Safe.
The user who run this web service requires View Safe Members permission on the Safe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the safe to return all its members
 @return ApiSafesGetSafeMembersRequest
*/
func (a *SafesApiService) SafesGetSafeMembers(ctx context.Context, safeUrlId string) ApiSafesGetSafeMembersRequest {
	return ApiSafesGetSafeMembersRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
	}
}

// Execute executes the request
//  @return SafeMemberResponse
func (a *SafesApiService) SafesGetSafeMembersExecute(r ApiSafesGetSafeMembersRequest) (*SafeMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SafeMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesGetSafeMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.useCache != nil {
		localVarQueryParams.Add("useCache", parameterToString(*r.useCache, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesGetSafesRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	limit *int64
	offset *int64
	useCache *bool
	sort *[]string
	search *string
	includeAccounts *bool
	extendedDetails *bool
}

func (r ApiSafesGetSafesRequest) Limit(limit int64) ApiSafesGetSafesRequest {
	r.limit = &limit
	return r
}

func (r ApiSafesGetSafesRequest) Offset(offset int64) ApiSafesGetSafesRequest {
	r.offset = &offset
	return r
}

func (r ApiSafesGetSafesRequest) UseCache(useCache bool) ApiSafesGetSafesRequest {
	r.useCache = &useCache
	return r
}

func (r ApiSafesGetSafesRequest) Sort(sort []string) ApiSafesGetSafesRequest {
	r.sort = &sort
	return r
}

func (r ApiSafesGetSafesRequest) Search(search string) ApiSafesGetSafesRequest {
	r.search = &search
	return r
}

// Whether or not to return accounts for each Safe as part of the response. If not sent, the value will be false.
func (r ApiSafesGetSafesRequest) IncludeAccounts(includeAccounts bool) ApiSafesGetSafesRequest {
	r.includeAccounts = &includeAccounts
	return r
}

// Whether or not to return all Safe data or only SafeName as part of the response. If not sent, the value will be true.
func (r ApiSafesGetSafesRequest) ExtendedDetails(extendedDetails bool) ApiSafesGetSafesRequest {
	r.extendedDetails = &extendedDetails
	return r
}

func (r ApiSafesGetSafesRequest) Execute() ([]SafeListItem, *http.Response, error) {
	return r.ApiService.SafesGetSafesExecute(r)
}

/*
SafesGetSafes Method for SafesGetSafes

This method returns a list of all Safes in the Vault that the user has permissions for.
The user who runs this web service must be a member of the Safes in the Vault that are returned in the list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSafesGetSafesRequest
*/
func (a *SafesApiService) SafesGetSafes(ctx context.Context) ApiSafesGetSafesRequest {
	return ApiSafesGetSafesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SafeListItem
func (a *SafesApiService) SafesGetSafesExecute(r ApiSafesGetSafesRequest) ([]SafeListItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SafeListItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesGetSafes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.useCache != nil {
		localVarQueryParams.Add("useCache", parameterToString(*r.useCache, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.includeAccounts != nil {
		localVarQueryParams.Add("includeAccounts", parameterToString(*r.includeAccounts, ""))
	}
	if r.extendedDetails != nil {
		localVarQueryParams.Add("extendedDetails", parameterToString(*r.extendedDetails, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesUpdateSafeRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
	updateSafeRequestBody *UpdateSafeRequestBody
}

func (r ApiSafesUpdateSafeRequest) UpdateSafeRequestBody(updateSafeRequestBody UpdateSafeRequestBody) ApiSafesUpdateSafeRequest {
	r.updateSafeRequestBody = &updateSafeRequestBody
	return r
}

func (r ApiSafesUpdateSafeRequest) Execute() (*UpdateSafeResponse, *http.Response, error) {
	return r.ApiService.SafesUpdateSafeExecute(r)
}

/*
SafesUpdateSafe Method for SafesUpdateSafe

This method updates a single Safe in the Vault.
The user who runs this web service requires Manage safe permissions and ViewOwners permissions on the safe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the Safe used when calling Safe APIs.
 @return ApiSafesUpdateSafeRequest
*/
func (a *SafesApiService) SafesUpdateSafe(ctx context.Context, safeUrlId string) ApiSafesUpdateSafeRequest {
	return ApiSafesUpdateSafeRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
	}
}

// Execute executes the request
//  @return UpdateSafeResponse
func (a *SafesApiService) SafesUpdateSafeExecute(r ApiSafesUpdateSafeRequest) (*UpdateSafeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateSafeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesUpdateSafe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSafeRequestBody == nil {
		return localVarReturnValue, nil, reportError("updateSafeRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSafeRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSafesUpdateSafeMemberRequest struct {
	ctx context.Context
	ApiService *SafesApiService
	safeUrlId string
	memberName string
	updateSafeMemberRequestBody *UpdateSafeMemberRequestBody
}

func (r ApiSafesUpdateSafeMemberRequest) UpdateSafeMemberRequestBody(updateSafeMemberRequestBody UpdateSafeMemberRequestBody) ApiSafesUpdateSafeMemberRequest {
	r.updateSafeMemberRequestBody = &updateSafeMemberRequestBody
	return r
}

func (r ApiSafesUpdateSafeMemberRequest) Execute() (*UpdateSafeMemberResponse, *http.Response, error) {
	return r.ApiService.SafesUpdateSafeMemberExecute(r)
}

/*
SafesUpdateSafeMember Method for SafesUpdateSafeMember

This method updates an existing safe member.
The user who run this web service requires Manage and View Safe Members permissions on the Safe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safeUrlId The name of the Safe used when calling Safe APIs.
 @param memberName The Vault user name, Domain user name or group name of the Safe member.
 @return ApiSafesUpdateSafeMemberRequest
*/
func (a *SafesApiService) SafesUpdateSafeMember(ctx context.Context, safeUrlId string, memberName string) ApiSafesUpdateSafeMemberRequest {
	return ApiSafesUpdateSafeMemberRequest{
		ApiService: a,
		ctx: ctx,
		safeUrlId: safeUrlId,
		memberName: memberName,
	}
}

// Execute executes the request
//  @return UpdateSafeMemberResponse
func (a *SafesApiService) SafesUpdateSafeMemberExecute(r ApiSafesUpdateSafeMemberRequest) (*UpdateSafeMemberResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateSafeMemberResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SafesApiService.SafesUpdateSafeMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Safes/{safeUrlId}/members/{memberName}"
	localVarPath = strings.Replace(localVarPath, "{"+"safeUrlId"+"}", url.PathEscape(parameterToString(r.safeUrlId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"memberName"+"}", url.PathEscape(parameterToString(r.memberName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSafeMemberRequestBody == nil {
		return localVarReturnValue, nil, reportError("updateSafeMemberRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml", "multipart/form-data", "application/vnd.cyberark.api+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSafeMemberRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
